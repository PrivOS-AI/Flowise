// Thêm props mới
export const AsyncDropdown = ({
    name,
    nodeData,
    value,
    onSelect,
    onItemDetailsFetch, // ✨ NEW: Callback khi cần fetch item details
    autoFillConfig,     // ✨ NEW: Config cho auto-fill
    // ... existing props
}) => {
    // ... existing code

    // ✨ NEW: Function để fetch item details và auto-fill
    const handleSelectionWithAutoFill = async (selection) => {
        const selectedValue = selection ? selection.name : ''
        
        // Set giá trị cho field hiện tại
        setInternalValue(selectedValue)
        onSelect(selectedValue)

        // ✨ NEW: Auto-fill logic
        if (selectedValue && autoFillConfig && onItemDetailsFetch) {
            try {
                // Fetch item details từ backend
                const itemDetails = await onItemDetailsFetch(selectedValue)
                
                // Trigger auto-fill cho các fields khác
                if (autoFillConfig.fieldsToFill && itemDetails) {
                    autoFillConfig.fieldsToFill.forEach(fieldConfig => {
                        const value = extractValueFromItem(itemDetails, fieldConfig.sourcePath)
                        if (value !== undefined) {
                            // Update field value thông qua callback
                            autoFillConfig.onFieldUpdate(fieldConfig.targetField, value)
                        }
                    })
                }
            } catch (error) {
                console.error('Error fetching item details for auto-fill:', error)
            }
        }
    }

    // Helper function để extract value từ item
    const extractValueFromItem = (item, sourcePath) => {
        if (!sourcePath) return null
        
        // Support nested path như "customFields.marketing_campaign_due_date_field.value"
        return sourcePath.split('.').reduce((obj, key) => {
            if (obj && obj[key] !== undefined) return obj[key]
            
            // Special handling cho customFields array
            if (key.includes('customFields[') && Array.isArray(obj.customFields)) {
                const fieldId = key.match(/customFields\[([^\]]+)\]/)?.[1]
                const field = obj.customFields.find(cf => cf.fieldId === fieldId)
                return field?.value
            }
            
            return null
        }, item)
    }

    return (
        <>
            <Autocomplete
                // ... existing props
                onChange={(e, selection) => {
                    if (multiple) {
                        // ... existing multiple logic
                    } else {
                        // ✨ MODIFIED: Use new handler with auto-fill
                        if (autoFillConfig) {
                            handleSelectionWithAutoFill(selection)
                        } else {
                            // Original logic for backward compatibility
                            const value = selection ? selection.name : ''
                            if (isCreateNewOption && value === '-create-') {
                                onCreateNew()
                            } else {
                                setInternalValue(value)
                                onSelect(value)
                            }
                        }
                    }
                }}
                // ... rest of component
            />
        </>
    )
}
// Thêm vào handleDataChange method
const handleDataChange = ({ inputParam, newValue, autoFillData }) => {
    data.inputs[inputParam.name] = newValue
    
    // ✨ NEW: Handle auto-fill data
    if (autoFillData) {
        Object.keys(autoFillData).forEach(fieldName => {
            data.inputs[fieldName] = autoFillData[fieldName]
        })
    }
    
    const allowedShowHideInputTypes = ['boolean', 'asyncOptions', 'asyncMultiOptions', 'options', 'multiOptions']
    if (allowedShowHideInputTypes.includes(inputParam.type)) {
        if (onCustomDataChange) {
            onCustomDataChange({ nodeId: data.id, inputParam, newValue, autoFillData })
        } else {
            onNodeDataChange({ nodeId: data.id, inputParam, newValue, autoFillData })
        }
    }
}

// ✨ NEW: Function để fetch item details
const fetchItemDetails = async (itemId, inputParam) => {
    if (!inputParam.autoFillConfig?.detailsEndpoint) return null
    
    try {
        const response = await fetch(`${baseURL}${inputParam.autoFillConfig.detailsEndpoint}/${itemId}`, {
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include'
        })
        return await response.json()
    } catch (error) {
        console.error('Error fetching item details:', error)
        return null
    }
}

// ✨ NEW: Auto-fill handler
const handleAutoFill = (targetField, value) => {
    const autoFillData = { [targetField]: value }
    handleDataChange({ 
        inputParam: { name: targetField }, 
        newValue: value,
        autoFillData 
    })
}

// Modify AsyncDropdown rendering
{(inputParam.type === 'asyncOptions' || inputParam.type === 'asyncMultiOptions') && (
    <>
        <div style={{ display: 'flex', flexDirection: 'row', alignItems: 'center', gap: 1 }}>
            <AsyncDropdown
                disabled={disabled}
                name={inputParam.name}
                nodeData={data}
                value={data.inputs[inputParam.name] ?? inputParam.default ?? 'choose an option'}
                freeSolo={inputParam.freeSolo}
                multiple={inputParam.type === 'asyncMultiOptions'}
                isCreateNewOption={EDITABLE_OPTIONS.includes(inputParam.name)}
                // ✨ NEW: Auto-fill props
                autoFillConfig={inputParam.autoFillConfig ? {
                    fieldsToFill: inputParam.autoFillConfig.fieldsToFill,
                    onFieldUpdate: handleAutoFill
                } : null}
                onItemDetailsFetch={inputParam.autoFillConfig ? 
                    (itemId) => fetchItemDetails(itemId, inputParam) : null
                }
                onSelect={(newValue) => {
                    if (inputParam.loadConfig) setReloadTimestamp(Date.now().toString())
                    handleDataChange({ inputParam, newValue })
                }}
                // ... other props
            />
        </div>
    </>
)}
class UpdateItemNode implements INode {
    constructor() {
        this.inputs = [
            {
                label: 'Select Item',
                name: 'selectedItem',
                type: 'asyncOptions',
                loadMethod: 'getItems',
                // ✨ NEW: Auto-fill configuration
                autoFillConfig: {
                    detailsEndpoint: '/api/v1/items', // Backend endpoint để fetch details
                    fieldsToFill: [
                        {
                            targetField: 'assignees',
                            sourcePath: 'customFields[marketing_campaign_assignees_field].value',
                            transform: (value) => Array.isArray(value) ? 
                                value.map(u => u.username).join(', ') : value
                        },
                        {
                            targetField: 'dueDate',
                            sourcePath: 'customFields[marketing_campaign_due_date_field].value',
                            transform: (value) => value ? new Date(value).toISOString().split('T')[0] : ''
                        },
                        {
                            targetField: 'startDate',
                            sourcePath: 'customFields[marketing_campaign_start_date_field].value',
                            transform: (value) => value ? new Date(value).toISOString().split('T')[0] : ''
                        },
                        {
                            targetField: 'endDate',
                            sourcePath: 'customFields[marketing_campaign_end_date_field].value',
                            transform: (value) => value ? new Date(value).toISOString().split('T')[0] : ''
                        },
                        {
                            targetField: 'note',
                            sourcePath: 'customFields[marketing_campaign_note_field].value'
                        }
                        // ... other fields
                    ]
                }
            },
            // Các fields sẽ được auto-fill
            {
                label: 'Assignees',
                name: 'assignees',
                type: 'string',
                optional: true,
                show: { selectedItem: '!choose an option' }
            },
            {
                label: 'Due Date',
                name: 'dueDate',
                type: 'date',
                optional: true,
                show: { selectedItem: '!choose an option' }
            },
            // ... other fields
        ]
    }

    //@ts-ignore
    loadMethods = {
        async getItems(_: INodeData, options: ICommonObject): Promise<INodeOptionsValue[]> {
            // Fetch items từ API và return options
            const response = await fetch('YOUR_API_ENDPOINT/items')
            const items = await response.json()
            
            return items.map(item => ({
                label: `${item.name} - ${item.description}`,
                name: item._id,
                description: `ID: ${item._id}`
            }))
        }
    }
}
// Thêm route để fetch item details
app.get('/api/v1/items/:id', async (req, res) => {
    try {
        const itemId = req.params.id
        const itemDetails = await fetchItemFromYourAPI(itemId)
        res.json(itemDetails)
    } catch (error) {
        res.status(500).json({ error: error.message })
    }
})
